/*
ElementStamp (subprogram)
*/
ElementStamp(e_) := block([type_, label_,
a_, b_, p_, IC_:0, Zc_, theta_, supported_:true],

/*R "R1" 1 2 R1 */

if length(e_) = 4 then
 [type_, label_, a_, b_]: e_
elseif length(e_) = 5 then
 [type_, label_, a_, b_, p_]: e_
else
 [type_, label_, a_, b_, p_, IC_]: e_,
 
if type_ = "R"
then (J[a_]: J[a_] + (V[a_]-V[b_])/p_,
 J[b_]: J[b_] + (V[b_]-V[a_])/p_)
 
elseif type_ = "V"
then (J[a_]: J[a_] + I[label_],
   J[b_]: J[b_] - I[label_],
   JJ: cons(V[a_]-V[b_]=p_, JJ),
   VV: cons(I[label_], VV) )
 
elseif type_ = "OpAmp"
then (a1_: first(a_), a2_: second(a_),
 J[b_]: J[b_] + I[label_],
 JJ: cons(V[a1_]-V[a2_]=0, JJ),
 VV: cons(I[label_], VV) )
 
else supported_: false,

supported_) $

/*
SALECx (main program)
*/

SALECx(circuit_, [w_]) := block([i_, n_],
if w_=[] then PhasorTransform_: false
 else PhasorTransform_: true,
 /* # je razlicito */ 
if w_#[] then
 print("Phasor Transform at angular frequency ", first(w_)),
if w_=[] then remvalue(s)
 else s: %i*first(w_),
 
 n_: lmax(flatten(
 map(lambda([x], part(x,[3,4])), circuit_)
 )),
 
 /* part uzima 3 i 4 kolonu */
 /* lambda vadi funkciju 
 /* map primeni funkciju koja 
 /* flatten vadi sve simbole koji se koriste (sve cvorove po jednom)
 /* koliko ima cvorova u nizu (tj listi svih cvorova */ 
  
 elementValues_: map(lambda([x],
 if length(x)>4 then part(x,5) else false), circuit_
 ),
 
 /* elementValues su 5. kolone unosa (vrednosti elemnata nasemi) 
 
 initialConditions_: map(lambda([x],
 if length(x)=6 then part(x,6) else false), circuit_
 ), 
 /* U(t0-) I(t0-0) pocetni uslovi
 
remvalue(I, J, JJ, V, VV),
/* ponistava sve vrednosti I J JJ V VV
/*  inicijalizuje celu lsitu J na nulu (koliko ima cvorova
for i_: 0 thru n_ do J[i_]: 0,
 JJ: [],
 V[0]: 0, // potencijal cvora
 potentials_: makelist(V[i_], i_, n_),
 VV: [],
//* pravi listu potencijala V1 V2 V3 ... Vn 
// on se posle koristi u linsolve kao parametre za resavanje
 m_: map(ElementStamp, circuit_), // lista elemenata kojis u validni[true. true, ...]
 // uzme funkciju ElementStamp i primeni na svaki element circuit_
 /* vrati listu validnosti elemenata 
 /* puni nizove J ova 
 // Iz elementStamp imamo J JJ VV popunjene liste
 // potentials = [V1, ... Vn]
 equationsVn_: makelist(J[i]=0, i, n_),
 // (svaka jednacina po struji): J[i] = 0 za svako i (1..n) cela lista
 equationsMNA_: append(equationsVn_, JJ),

 variablesMNA_: append(potentials_, VV),
 
 responseMNA_: linsolve(equationsMNA_, variablesMNA_),
 
if SALECxPrint then (
print("Symbolic Analysis of Linear Electric Circuits with Maxima"
print("SALECx version 1.0, Prof. Dr. Dejan Tošić, tosic@etf.rs"
print("Number of nodes excluding 0 node: ", n_),
print("Electric circuit specification:", circuit_),
print("Supported element: ", m_),
print("Element values: ", elementValues_),
print("Initial conditions: ", initialConditions_),
print("MNA equations: ", equationsMNA_),
print("MNA variables: ", variablesMNA_)
 ),
 
responseMNA_) $

/*
SALECxPrint (reserved symbol, verbose option)
*/

SALECxPrint: false $

print("Dejan Tosic, SALECx 2019 v1.0");
print("Symbolic Analysis of Linear Electric Circuits with Maxi